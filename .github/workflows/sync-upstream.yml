name: Sync with Upstream

on:
  schedule:
    # æ¯å¤©è¿è¡Œ 4 æ¬¡ (åŒ—äº¬æ—¶é—´ +8: 00:00, 06:00, 12:00, 18:00)
    # å¯¹åº” UTC æ—¶é—´: 16:00(å‰ä¸€å¤©), 22:00(å‰ä¸€å¤©), 04:00, 10:00
    - cron: '0 4,10,16,22 * * *'
  workflow_dispatch: # æ”¯æŒæ‰‹åŠ¨è§¦å‘

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream remote
        run: |
          git remote add upstream https://github.com/router-for-me/Cli-Proxy-API-Management-Center.git || true
          git fetch upstream
          git fetch upstream --tags

      - name: Check for updates
        id: check
        run: |
          UPSTREAM_SHA=$(git rev-parse upstream/main)
          if git merge-base --is-ancestor $UPSTREAM_SHA HEAD; then
            echo "already_up_to_date=true" >> $GITHUB_OUTPUT
            echo "âœ… Already up to date with upstream"
          else
            echo "already_up_to_date=false" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Updates available from upstream"
          fi

      - name: Get upstream latest release
        id: upstream_release
        run: |
          # è·å–ä¸Šæ¸¸æœ€æ–° release ä¿¡æ¯
          RELEASE_INFO=$(curl -s https://api.github.com/repos/router-for-me/Cli-Proxy-API-Management-Center/releases/latest)
          UPSTREAM_TAG=$(echo "$RELEASE_INFO" | jq -r '.tag_name // empty')
          UPSTREAM_BODY=$(echo "$RELEASE_INFO" | jq -r '.body // empty')

          if [ -n "$UPSTREAM_TAG" ]; then
            echo "tag=$UPSTREAM_TAG" >> $GITHUB_OUTPUT
            echo "has_release=true" >> $GITHUB_OUTPUT
            # ä¿å­˜ release body åˆ°æ–‡ä»¶ï¼ˆé¿å…ç‰¹æ®Šå­—ç¬¦é—®é¢˜ï¼‰
            echo "$UPSTREAM_BODY" > /tmp/upstream_release_body.md
            echo "ğŸ“¦ Upstream latest release: $UPSTREAM_TAG"
          else
            echo "has_release=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ No upstream release found"
          fi

      - name: Calculate next release version
        id: local_release
        if: steps.upstream_release.outputs.has_release == 'true'
        run: |
          UPSTREAM_TAG="${{ steps.upstream_release.outputs.tag }}"
          BASE_TAG="${UPSTREAM_TAG}-plus"

          # è·å–æ‰€æœ‰åŸºäºè¯¥ä¸Šæ¸¸ç‰ˆæœ¬çš„ plus releases
          # æ ¼å¼: v1.4.9-plus, v1.4.9-plus.1, v1.4.9-plus.2, ...
          EXISTING_TAGS=$(gh api repos/${{ github.repository }}/releases --paginate --jq '.[].tag_name' 2>/dev/null | grep "^${BASE_TAG}" || true)

          if [ -z "$EXISTING_TAGS" ]; then
            # æ²¡æœ‰ä»»ä½• plus releaseï¼Œä½¿ç”¨åŸºç¡€ç‰ˆæœ¬
            NEXT_TAG="${BASE_TAG}"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ No existing release, will create $NEXT_TAG"
          else
            # æ‰¾åˆ°æœ€å¤§çš„ç‰ˆæœ¬å·
            MAX_NUM=-1
            while IFS= read -r tag; do
              if [ "$tag" == "$BASE_TAG" ]; then
                # v1.4.9-plus ç›¸å½“äº .0
                NUM=0
              else
                # v1.4.9-plus.N æå– N
                NUM=$(echo "$tag" | sed "s/^${BASE_TAG}\.//" | grep -E '^[0-9]+$' || echo "-1")
              fi
              if [ "$NUM" -gt "$MAX_NUM" ]; then
                MAX_NUM=$NUM
              fi
            done <<< "$EXISTING_TAGS"

            # é€’å¢ç‰ˆæœ¬å·
            NEXT_NUM=$((MAX_NUM + 1))
            if [ "$NEXT_NUM" -eq 0 ]; then
              NEXT_TAG="${BASE_TAG}"
            else
              NEXT_TAG="${BASE_TAG}.${NEXT_NUM}"
            fi
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Found existing releases, next version: $NEXT_TAG"
          fi

          echo "next_tag=$NEXT_TAG" >> $GITHUB_OUTPUT
          echo "base_tag=$BASE_TAG" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        if: steps.check.outputs.already_up_to_date == 'false'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Merge upstream
        if: steps.check.outputs.already_up_to_date == 'false'
        id: merge
        run: |
          if git merge upstream/main --no-edit -m "Merge upstream changes $(date +%Y-%m-%d)"; then
            echo "merge_success=true" >> $GITHUB_OUTPUT
            echo "âœ… Merge successful"
          else
            echo "merge_success=false" >> $GITHUB_OUTPUT
            # ä¿å­˜å†²çªæ–‡ä»¶åˆ—è¡¨
            git diff --name-only --diff-filter=U > /tmp/conflict_files.txt
            git merge --abort
            echo "âš ï¸ Merge conflict detected"
          fi

      - name: Build and package
        if: steps.check.outputs.already_up_to_date == 'false' && steps.merge.outputs.merge_success == 'true'
        id: build
        env:
          VERSION: ${{ steps.local_release.outputs.next_tag }}
        run: |
          npm ci
          if npm run build; then
            echo "build_success=true" >> $GITHUB_OUTPUT
            echo "âœ… Build successful"
          else
            echo "build_success=false" >> $GITHUB_OUTPUT
            echo "âŒ Build failed"
          fi

      - name: Push to main (merge and build success)
        if: steps.merge.outputs.merge_success == 'true' && steps.build.outputs.build_success == 'true'
        run: |
          git push origin main
          echo "âœ… Successfully synced with upstream"

      - name: Create Release
        if: |
          steps.upstream_release.outputs.has_release == 'true' &&
          (steps.build.outputs.build_success == 'true' || steps.check.outputs.already_up_to_date == 'true')
        run: |
          UPSTREAM_TAG="${{ steps.upstream_release.outputs.tag }}"
          RELEASE_TAG="${{ steps.local_release.outputs.next_tag }}"

          # å¦‚æœä»£ç å·²æ˜¯æœ€æ–°ä½†æ²¡æœ‰ releaseï¼Œéœ€è¦å…ˆæ„å»º
          if [ "${{ steps.check.outputs.already_up_to_date }}" == "true" ]; then
            npm ci
            export VERSION="${RELEASE_TAG}"
            npm run build
          fi

          # é‡å‘½åæ„å»ºäº§ç‰©ï¼ˆä¸ä¸Šæ¸¸ release.yml ä¿æŒä¸€è‡´ï¼‰
          mv dist/index.html dist/management.html

          # è¯»å–ä¸Šæ¸¸ release body
          UPSTREAM_BODY=""
          if [ -f /tmp/upstream_release_body.md ]; then
            UPSTREAM_BODY=$(cat /tmp/upstream_release_body.md)
          fi

          # æ„å»º release notes å†™å…¥æ–‡ä»¶
          cat > /tmp/release_notes.md << 'RELEASE_EOF'
          ## ğŸ”„ åŒæ­¥ä¸Šæ¸¸

          æ­¤ç‰ˆæœ¬åŒæ­¥è‡ªä¸Šæ¸¸ä»“åº“ [router-for-me/Cli-Proxy-API-Management-Center](https://github.com/router-for-me/Cli-Proxy-API-Management-Center)

          ### âœ¨ Fork å¢å¼ºåŠŸèƒ½
          - Kiro (AWS CodeWhisperer) é…é¢æ˜¾ç¤º
          - GitHub Copilot é…é¢æ˜¾ç¤º

          ---

          ### ğŸ“‹ ä¸Šæ¸¸æ›´æ–°æ—¥å¿—

          RELEASE_EOF

          # è¿½åŠ ä¸Šæ¸¸ release body
          echo "$UPSTREAM_BODY" >> /tmp/release_notes.md

          # åˆ›å»º release å¹¶ä¸Šä¼ æ„å»ºäº§ç‰©
          gh release create "$RELEASE_TAG" \
            --repo ${{ github.repository }} \
            --title "$RELEASE_TAG (åŸºäº $UPSTREAM_TAG)" \
            --notes-file /tmp/release_notes.md \
            dist/management.html

          echo "âœ… Release $RELEASE_TAG created successfully"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Report merge conflict
        if: steps.merge.outputs.merge_success == 'false'
        run: |
          echo "::error::âš ï¸ ä¸Šæ¸¸åŒæ­¥å†²çªï¼Œéœ€è¦æ‰‹åŠ¨è§£å†³"
          echo ""
          echo "å†²çªæ–‡ä»¶åˆ—è¡¨ï¼š"
          if [ -f /tmp/conflict_files.txt ]; then
            cat /tmp/conflict_files.txt
          fi
          echo ""
          echo "è¯·å‚è€ƒ docs/merge.md æ‰‹åŠ¨è§£å†³å†²çª"
          exit 1

      - name: Report build failure
        if: steps.merge.outputs.merge_success == 'true' && steps.build.outputs.build_success == 'false'
        run: |
          git reset --hard HEAD~1
          echo "::error::âŒ ä¸Šæ¸¸åŒæ­¥åæ„å»ºå¤±è´¥ï¼Œå·²è‡ªåŠ¨å›æ»š"
          echo ""
          echo "è¯·å‚è€ƒ docs/merge.md æ‰‹åŠ¨è§£å†³"
          exit 1
